// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PDMESSAGES_H_
#define FLATBUFFERS_GENERATED_PDMESSAGES_H_

#include "flatbuffers/flatbuffers.h"

struct BasicRequest;
struct BasicRequestBuilder;

struct SourceFilesReply;
struct SourceFilesReplyBuilder;

struct FileTargetRequest;
struct FileTargetRequestBuilder;

struct TargetReply;
struct TargetReplyBuilder;

struct ExceptionLocationRequest;
struct ExceptionLocationRequestBuilder;

struct LocalsRequest;
struct LocalsRequestBuilder;

struct FileLineBreakpoint;
struct FileLineBreakpointBuilder;

struct Variable;
struct VariableBuilder;

struct CallstackEntry;
struct CallstackEntryBuilder;

struct Callstack;
struct CallstackBuilder;

struct LocalsReply;
struct LocalsReplyBuilder;

struct ExceptionLocationReply;
struct ExceptionLocationReplyBuilder;

struct FrameSelectRequest;
struct FrameSelectRequestBuilder;

struct Message;
struct MessageBuilder;

enum BasicRequestEnum {
  BasicRequestEnum_SourceFiles = 0,
  BasicRequestEnum_Callstack = 1,
  BasicRequestEnum_MIN = BasicRequestEnum_SourceFiles,
  BasicRequestEnum_MAX = BasicRequestEnum_Callstack
};

inline const BasicRequestEnum (&EnumValuesBasicRequestEnum())[2] {
  static const BasicRequestEnum values[] = {
    BasicRequestEnum_SourceFiles,
    BasicRequestEnum_Callstack
  };
  return values;
}

inline const char * const *EnumNamesBasicRequestEnum() {
  static const char * const names[3] = {
    "SourceFiles",
    "Callstack",
    nullptr
  };
  return names;
}

inline const char *EnumNameBasicRequestEnum(BasicRequestEnum e) {
  if (flatbuffers::IsOutRange(e, BasicRequestEnum_SourceFiles, BasicRequestEnum_Callstack)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBasicRequestEnum()[index];
}

enum ExpandVarsTypeEnum {
  ExpandVarsTypeEnum_AllVariables = 0,
  ExpandVarsTypeEnum_Single = 1,
  ExpandVarsTypeEnum_MIN = ExpandVarsTypeEnum_AllVariables,
  ExpandVarsTypeEnum_MAX = ExpandVarsTypeEnum_Single
};

inline const ExpandVarsTypeEnum (&EnumValuesExpandVarsTypeEnum())[2] {
  static const ExpandVarsTypeEnum values[] = {
    ExpandVarsTypeEnum_AllVariables,
    ExpandVarsTypeEnum_Single
  };
  return values;
}

inline const char * const *EnumNamesExpandVarsTypeEnum() {
  static const char * const names[3] = {
    "AllVariables",
    "Single",
    nullptr
  };
  return names;
}

inline const char *EnumNameExpandVarsTypeEnum(ExpandVarsTypeEnum e) {
  if (flatbuffers::IsOutRange(e, ExpandVarsTypeEnum_AllVariables, ExpandVarsTypeEnum_Single)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExpandVarsTypeEnum()[index];
}

enum MessageType {
  MessageType_NONE = 0,
  MessageType_file_target_request = 1,
  MessageType_target_reply = 2,
  MessageType_exception_location_request = 3,
  MessageType_exception_location_reply = 4,
  MessageType_file_line_breakpoint_request = 5,
  MessageType_locals_request = 6,
  MessageType_locals_reply = 7,
  MessageType_frame_select_request = 8,
  MessageType_basic_request = 9,
  MessageType_callstack_reply = 10,
  MessageType_source_files_reply = 11,
  MessageType_MIN = MessageType_NONE,
  MessageType_MAX = MessageType_source_files_reply
};

inline const MessageType (&EnumValuesMessageType())[12] {
  static const MessageType values[] = {
    MessageType_NONE,
    MessageType_file_target_request,
    MessageType_target_reply,
    MessageType_exception_location_request,
    MessageType_exception_location_reply,
    MessageType_file_line_breakpoint_request,
    MessageType_locals_request,
    MessageType_locals_reply,
    MessageType_frame_select_request,
    MessageType_basic_request,
    MessageType_callstack_reply,
    MessageType_source_files_reply
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[13] = {
    "NONE",
    "file_target_request",
    "target_reply",
    "exception_location_request",
    "exception_location_reply",
    "file_line_breakpoint_request",
    "locals_request",
    "locals_reply",
    "frame_select_request",
    "basic_request",
    "callstack_reply",
    "source_files_reply",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (flatbuffers::IsOutRange(e, MessageType_NONE, MessageType_source_files_reply)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

template<typename T> struct MessageTypeTraits {
  static const MessageType enum_value = MessageType_NONE;
};

template<> struct MessageTypeTraits<FileTargetRequest> {
  static const MessageType enum_value = MessageType_file_target_request;
};

template<> struct MessageTypeTraits<TargetReply> {
  static const MessageType enum_value = MessageType_target_reply;
};

template<> struct MessageTypeTraits<ExceptionLocationRequest> {
  static const MessageType enum_value = MessageType_exception_location_request;
};

template<> struct MessageTypeTraits<ExceptionLocationReply> {
  static const MessageType enum_value = MessageType_exception_location_reply;
};

template<> struct MessageTypeTraits<FileLineBreakpoint> {
  static const MessageType enum_value = MessageType_file_line_breakpoint_request;
};

template<> struct MessageTypeTraits<LocalsRequest> {
  static const MessageType enum_value = MessageType_locals_request;
};

template<> struct MessageTypeTraits<LocalsReply> {
  static const MessageType enum_value = MessageType_locals_reply;
};

template<> struct MessageTypeTraits<FrameSelectRequest> {
  static const MessageType enum_value = MessageType_frame_select_request;
};

template<> struct MessageTypeTraits<BasicRequest> {
  static const MessageType enum_value = MessageType_basic_request;
};

template<> struct MessageTypeTraits<Callstack> {
  static const MessageType enum_value = MessageType_callstack_reply;
};

template<> struct MessageTypeTraits<SourceFilesReply> {
  static const MessageType enum_value = MessageType_source_files_reply;
};

bool VerifyMessageType(flatbuffers::Verifier &verifier, const void *obj, MessageType type);
bool VerifyMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct BasicRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BasicRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  BasicRequestEnum id() const {
    return static_cast<BasicRequestEnum>(GetField<int16_t>(VT_ID, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct BasicRequestBuilder {
  typedef BasicRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(BasicRequestEnum id) {
    fbb_.AddElement<int16_t>(BasicRequest::VT_ID, static_cast<int16_t>(id), 0);
  }
  explicit BasicRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BasicRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BasicRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<BasicRequest> CreateBasicRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    BasicRequestEnum id = BasicRequestEnum_SourceFiles) {
  BasicRequestBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct SourceFilesReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SourceFilesReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRIES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *entries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ENTRIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTRIES) &&
           verifier.VerifyVector(entries()) &&
           verifier.VerifyVectorOfStrings(entries()) &&
           verifier.EndTable();
  }
};

struct SourceFilesReplyBuilder {
  typedef SourceFilesReply Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> entries) {
    fbb_.AddOffset(SourceFilesReply::VT_ENTRIES, entries);
  }
  explicit SourceFilesReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SourceFilesReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SourceFilesReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<SourceFilesReply> CreateSourceFilesReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> entries = 0) {
  SourceFilesReplyBuilder builder_(_fbb);
  builder_.add_entries(entries);
  return builder_.Finish();
}

inline flatbuffers::Offset<SourceFilesReply> CreateSourceFilesReplyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *entries = nullptr) {
  auto entries__ = entries ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*entries) : 0;
  return CreateSourceFilesReply(
      _fbb,
      entries__);
}

struct FileTargetRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FileTargetRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4
  };
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           verifier.EndTable();
  }
};

struct FileTargetRequestBuilder {
  typedef FileTargetRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(FileTargetRequest::VT_PATH, path);
  }
  explicit FileTargetRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FileTargetRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileTargetRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileTargetRequest> CreateFileTargetRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> path = 0) {
  FileTargetRequestBuilder builder_(_fbb);
  builder_.add_path(path);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileTargetRequest> CreateFileTargetRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return CreateFileTargetRequest(
      _fbb,
      path__);
}

struct TargetReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TargetReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_ERROR_MESSAGE = 6
  };
  bool status() const {
    return GetField<uint8_t>(VT_STATUS, 0) != 0;
  }
  const flatbuffers::String *error_message() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_ERROR_MESSAGE) &&
           verifier.VerifyString(error_message()) &&
           verifier.EndTable();
  }
};

struct TargetReplyBuilder {
  typedef TargetReply Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(bool status) {
    fbb_.AddElement<uint8_t>(TargetReply::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_error_message(flatbuffers::Offset<flatbuffers::String> error_message) {
    fbb_.AddOffset(TargetReply::VT_ERROR_MESSAGE, error_message);
  }
  explicit TargetReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TargetReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TargetReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<TargetReply> CreateTargetReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool status = false,
    flatbuffers::Offset<flatbuffers::String> error_message = 0) {
  TargetReplyBuilder builder_(_fbb);
  builder_.add_error_message(error_message);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<TargetReply> CreateTargetReplyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool status = false,
    const char *error_message = nullptr) {
  auto error_message__ = error_message ? _fbb.CreateString(error_message) : 0;
  return CreateTargetReply(
      _fbb,
      status,
      error_message__);
}

struct ExceptionLocationRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExceptionLocationRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ExceptionLocationRequestBuilder {
  typedef ExceptionLocationRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExceptionLocationRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExceptionLocationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExceptionLocationRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExceptionLocationRequest> CreateExceptionLocationRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExceptionLocationRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LocalsRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LocalsRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TREE = 4,
    VT_TYPE = 6
  };
  const flatbuffers::Vector<uint16_t> *tree() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_TREE);
  }
  ExpandVarsTypeEnum type() const {
    return static_cast<ExpandVarsTypeEnum>(GetField<int16_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TREE) &&
           verifier.VerifyVector(tree()) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct LocalsRequestBuilder {
  typedef LocalsRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tree(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> tree) {
    fbb_.AddOffset(LocalsRequest::VT_TREE, tree);
  }
  void add_type(ExpandVarsTypeEnum type) {
    fbb_.AddElement<int16_t>(LocalsRequest::VT_TYPE, static_cast<int16_t>(type), 0);
  }
  explicit LocalsRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LocalsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LocalsRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<LocalsRequest> CreateLocalsRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> tree = 0,
    ExpandVarsTypeEnum type = ExpandVarsTypeEnum_AllVariables) {
  LocalsRequestBuilder builder_(_fbb);
  builder_.add_tree(tree);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<LocalsRequest> CreateLocalsRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *tree = nullptr,
    ExpandVarsTypeEnum type = ExpandVarsTypeEnum_AllVariables) {
  auto tree__ = tree ? _fbb.CreateVector<uint16_t>(*tree) : 0;
  return CreateLocalsRequest(
      _fbb,
      tree__,
      type);
}

struct FileLineBreakpoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FileLineBreakpointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILENAME = 4,
    VT_LINE = 6,
    VT_ADD_REMOVE = 8
  };
  const flatbuffers::String *filename() const {
    return GetPointer<const flatbuffers::String *>(VT_FILENAME);
  }
  int32_t line() const {
    return GetField<int32_t>(VT_LINE, 0);
  }
  bool add_remove() const {
    return GetField<uint8_t>(VT_ADD_REMOVE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyField<int32_t>(verifier, VT_LINE) &&
           VerifyField<uint8_t>(verifier, VT_ADD_REMOVE) &&
           verifier.EndTable();
  }
};

struct FileLineBreakpointBuilder {
  typedef FileLineBreakpoint Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) {
    fbb_.AddOffset(FileLineBreakpoint::VT_FILENAME, filename);
  }
  void add_line(int32_t line) {
    fbb_.AddElement<int32_t>(FileLineBreakpoint::VT_LINE, line, 0);
  }
  void add_add_remove(bool add_remove) {
    fbb_.AddElement<uint8_t>(FileLineBreakpoint::VT_ADD_REMOVE, static_cast<uint8_t>(add_remove), 0);
  }
  explicit FileLineBreakpointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FileLineBreakpoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileLineBreakpoint>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileLineBreakpoint> CreateFileLineBreakpoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> filename = 0,
    int32_t line = 0,
    bool add_remove = false) {
  FileLineBreakpointBuilder builder_(_fbb);
  builder_.add_line(line);
  builder_.add_filename(filename);
  builder_.add_add_remove(add_remove);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileLineBreakpoint> CreateFileLineBreakpointDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr,
    int32_t line = 0,
    bool add_remove = false) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return CreateFileLineBreakpoint(
      _fbb,
      filename__,
      line,
      add_remove);
}

struct Variable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VariableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6,
    VT_TYPE = 8,
    VT_ADDRESS = 10,
    VT_MAY_HAVE_CHILDREN = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  bool may_have_children() const {
    return GetField<uint8_t>(VT_MAY_HAVE_CHILDREN, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS) &&
           VerifyField<uint8_t>(verifier, VT_MAY_HAVE_CHILDREN) &&
           verifier.EndTable();
  }
};

struct VariableBuilder {
  typedef Variable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Variable::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(Variable::VT_VALUE, value);
  }
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Variable::VT_TYPE, type);
  }
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(Variable::VT_ADDRESS, address, 0);
  }
  void add_may_have_children(bool may_have_children) {
    fbb_.AddElement<uint8_t>(Variable::VT_MAY_HAVE_CHILDREN, static_cast<uint8_t>(may_have_children), 0);
  }
  explicit VariableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Variable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Variable>(end);
    return o;
  }
};

inline flatbuffers::Offset<Variable> CreateVariable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    uint64_t address = 0,
    bool may_have_children = false) {
  VariableBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_type(type);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_may_have_children(may_have_children);
  return builder_.Finish();
}

inline flatbuffers::Offset<Variable> CreateVariableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *value = nullptr,
    const char *type = nullptr,
    uint64_t address = 0,
    bool may_have_children = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  return CreateVariable(
      _fbb,
      name__,
      value__,
      type__,
      address,
      may_have_children);
}

struct CallstackEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallstackEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_DESC = 6,
    VT_LANG = 8,
    VT_FILE = 10,
    VT_LINE = 12
  };
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  const flatbuffers::String *desc() const {
    return GetPointer<const flatbuffers::String *>(VT_DESC);
  }
  const flatbuffers::String *lang() const {
    return GetPointer<const flatbuffers::String *>(VT_LANG);
  }
  const flatbuffers::String *file() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE);
  }
  int32_t line() const {
    return GetField<int32_t>(VT_LINE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS) &&
           VerifyOffset(verifier, VT_DESC) &&
           verifier.VerifyString(desc()) &&
           VerifyOffset(verifier, VT_LANG) &&
           verifier.VerifyString(lang()) &&
           VerifyOffset(verifier, VT_FILE) &&
           verifier.VerifyString(file()) &&
           VerifyField<int32_t>(verifier, VT_LINE) &&
           verifier.EndTable();
  }
};

struct CallstackEntryBuilder {
  typedef CallstackEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(CallstackEntry::VT_ADDRESS, address, 0);
  }
  void add_desc(flatbuffers::Offset<flatbuffers::String> desc) {
    fbb_.AddOffset(CallstackEntry::VT_DESC, desc);
  }
  void add_lang(flatbuffers::Offset<flatbuffers::String> lang) {
    fbb_.AddOffset(CallstackEntry::VT_LANG, lang);
  }
  void add_file(flatbuffers::Offset<flatbuffers::String> file) {
    fbb_.AddOffset(CallstackEntry::VT_FILE, file);
  }
  void add_line(int32_t line) {
    fbb_.AddElement<int32_t>(CallstackEntry::VT_LINE, line, 0);
  }
  explicit CallstackEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CallstackEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallstackEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallstackEntry> CreateCallstackEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    flatbuffers::Offset<flatbuffers::String> desc = 0,
    flatbuffers::Offset<flatbuffers::String> lang = 0,
    flatbuffers::Offset<flatbuffers::String> file = 0,
    int32_t line = 0) {
  CallstackEntryBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_line(line);
  builder_.add_file(file);
  builder_.add_lang(lang);
  builder_.add_desc(desc);
  return builder_.Finish();
}

inline flatbuffers::Offset<CallstackEntry> CreateCallstackEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    const char *desc = nullptr,
    const char *lang = nullptr,
    const char *file = nullptr,
    int32_t line = 0) {
  auto desc__ = desc ? _fbb.CreateString(desc) : 0;
  auto lang__ = lang ? _fbb.CreateString(lang) : 0;
  auto file__ = file ? _fbb.CreateString(file) : 0;
  return CreateCallstackEntry(
      _fbb,
      address,
      desc__,
      lang__,
      file__,
      line);
}

struct Callstack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallstackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRIES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<CallstackEntry>> *entries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CallstackEntry>> *>(VT_ENTRIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTRIES) &&
           verifier.VerifyVector(entries()) &&
           verifier.VerifyVectorOfTables(entries()) &&
           verifier.EndTable();
  }
};

struct CallstackBuilder {
  typedef Callstack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CallstackEntry>>> entries) {
    fbb_.AddOffset(Callstack::VT_ENTRIES, entries);
  }
  explicit CallstackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Callstack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Callstack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Callstack> CreateCallstack(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CallstackEntry>>> entries = 0) {
  CallstackBuilder builder_(_fbb);
  builder_.add_entries(entries);
  return builder_.Finish();
}

inline flatbuffers::Offset<Callstack> CreateCallstackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<CallstackEntry>> *entries = nullptr) {
  auto entries__ = entries ? _fbb.CreateVector<flatbuffers::Offset<CallstackEntry>>(*entries) : 0;
  return CreateCallstack(
      _fbb,
      entries__);
}

struct LocalsReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LocalsReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VARIABLES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Variable>> *variables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Variable>> *>(VT_VARIABLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VARIABLES) &&
           verifier.VerifyVector(variables()) &&
           verifier.VerifyVectorOfTables(variables()) &&
           verifier.EndTable();
  }
};

struct LocalsReplyBuilder {
  typedef LocalsReply Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_variables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Variable>>> variables) {
    fbb_.AddOffset(LocalsReply::VT_VARIABLES, variables);
  }
  explicit LocalsReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LocalsReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LocalsReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<LocalsReply> CreateLocalsReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Variable>>> variables = 0) {
  LocalsReplyBuilder builder_(_fbb);
  builder_.add_variables(variables);
  return builder_.Finish();
}

inline flatbuffers::Offset<LocalsReply> CreateLocalsReplyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Variable>> *variables = nullptr) {
  auto variables__ = variables ? _fbb.CreateVector<flatbuffers::Offset<Variable>>(*variables) : 0;
  return CreateLocalsReply(
      _fbb,
      variables__);
}

struct ExceptionLocationReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExceptionLocationReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILENAME = 4,
    VT_LINE = 6,
    VT_ADDRESS = 8
  };
  const flatbuffers::String *filename() const {
    return GetPointer<const flatbuffers::String *>(VT_FILENAME);
  }
  int32_t line() const {
    return GetField<int32_t>(VT_LINE, 0);
  }
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyField<int32_t>(verifier, VT_LINE) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS) &&
           verifier.EndTable();
  }
};

struct ExceptionLocationReplyBuilder {
  typedef ExceptionLocationReply Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) {
    fbb_.AddOffset(ExceptionLocationReply::VT_FILENAME, filename);
  }
  void add_line(int32_t line) {
    fbb_.AddElement<int32_t>(ExceptionLocationReply::VT_LINE, line, 0);
  }
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(ExceptionLocationReply::VT_ADDRESS, address, 0);
  }
  explicit ExceptionLocationReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExceptionLocationReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExceptionLocationReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExceptionLocationReply> CreateExceptionLocationReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> filename = 0,
    int32_t line = 0,
    uint64_t address = 0) {
  ExceptionLocationReplyBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_line(line);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExceptionLocationReply> CreateExceptionLocationReplyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr,
    int32_t line = 0,
    uint64_t address = 0) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return CreateExceptionLocationReply(
      _fbb,
      filename__,
      line,
      address);
}

struct FrameSelectRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FrameSelectRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAME_INDEX = 4
  };
  int32_t frame_index() const {
    return GetField<int32_t>(VT_FRAME_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FRAME_INDEX) &&
           verifier.EndTable();
  }
};

struct FrameSelectRequestBuilder {
  typedef FrameSelectRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame_index(int32_t frame_index) {
    fbb_.AddElement<int32_t>(FrameSelectRequest::VT_FRAME_INDEX, frame_index, 0);
  }
  explicit FrameSelectRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FrameSelectRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FrameSelectRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<FrameSelectRequest> CreateFrameSelectRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frame_index = 0) {
  FrameSelectRequestBuilder builder_(_fbb);
  builder_.add_frame_index(frame_index);
  return builder_.Finish();
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6,
    VT_USER_DATA = 8
  };
  MessageType message_type() const {
    return static_cast<MessageType>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const FileTargetRequest *message_as_file_target_request() const {
    return message_type() == MessageType_file_target_request ? static_cast<const FileTargetRequest *>(message()) : nullptr;
  }
  const TargetReply *message_as_target_reply() const {
    return message_type() == MessageType_target_reply ? static_cast<const TargetReply *>(message()) : nullptr;
  }
  const ExceptionLocationRequest *message_as_exception_location_request() const {
    return message_type() == MessageType_exception_location_request ? static_cast<const ExceptionLocationRequest *>(message()) : nullptr;
  }
  const ExceptionLocationReply *message_as_exception_location_reply() const {
    return message_type() == MessageType_exception_location_reply ? static_cast<const ExceptionLocationReply *>(message()) : nullptr;
  }
  const FileLineBreakpoint *message_as_file_line_breakpoint_request() const {
    return message_type() == MessageType_file_line_breakpoint_request ? static_cast<const FileLineBreakpoint *>(message()) : nullptr;
  }
  const LocalsRequest *message_as_locals_request() const {
    return message_type() == MessageType_locals_request ? static_cast<const LocalsRequest *>(message()) : nullptr;
  }
  const LocalsReply *message_as_locals_reply() const {
    return message_type() == MessageType_locals_reply ? static_cast<const LocalsReply *>(message()) : nullptr;
  }
  const FrameSelectRequest *message_as_frame_select_request() const {
    return message_type() == MessageType_frame_select_request ? static_cast<const FrameSelectRequest *>(message()) : nullptr;
  }
  const BasicRequest *message_as_basic_request() const {
    return message_type() == MessageType_basic_request ? static_cast<const BasicRequest *>(message()) : nullptr;
  }
  const Callstack *message_as_callstack_reply() const {
    return message_type() == MessageType_callstack_reply ? static_cast<const Callstack *>(message()) : nullptr;
  }
  const SourceFilesReply *message_as_source_files_reply() const {
    return message_type() == MessageType_source_files_reply ? static_cast<const SourceFilesReply *>(message()) : nullptr;
  }
  const flatbuffers::Vector<uint8_t> *user_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_USER_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessageType(verifier, message(), message_type()) &&
           VerifyOffset(verifier, VT_USER_DATA) &&
           verifier.VerifyVector(user_data()) &&
           verifier.EndTable();
  }
};

template<> inline const FileTargetRequest *Message::message_as<FileTargetRequest>() const {
  return message_as_file_target_request();
}

template<> inline const TargetReply *Message::message_as<TargetReply>() const {
  return message_as_target_reply();
}

template<> inline const ExceptionLocationRequest *Message::message_as<ExceptionLocationRequest>() const {
  return message_as_exception_location_request();
}

template<> inline const ExceptionLocationReply *Message::message_as<ExceptionLocationReply>() const {
  return message_as_exception_location_reply();
}

template<> inline const FileLineBreakpoint *Message::message_as<FileLineBreakpoint>() const {
  return message_as_file_line_breakpoint_request();
}

template<> inline const LocalsRequest *Message::message_as<LocalsRequest>() const {
  return message_as_locals_request();
}

template<> inline const LocalsReply *Message::message_as<LocalsReply>() const {
  return message_as_locals_reply();
}

template<> inline const FrameSelectRequest *Message::message_as<FrameSelectRequest>() const {
  return message_as_frame_select_request();
}

template<> inline const BasicRequest *Message::message_as<BasicRequest>() const {
  return message_as_basic_request();
}

template<> inline const Callstack *Message::message_as<Callstack>() const {
  return message_as_callstack_reply();
}

template<> inline const SourceFilesReply *Message::message_as<SourceFilesReply>() const {
  return message_as_source_files_reply();
}

struct MessageBuilder {
  typedef Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(MessageType message_type) {
    fbb_.AddElement<uint8_t>(Message::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Message::VT_MESSAGE, message);
  }
  void add_user_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> user_data) {
    fbb_.AddOffset(Message::VT_USER_DATA, user_data);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    MessageType message_type = MessageType_NONE,
    flatbuffers::Offset<void> message = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> user_data = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_user_data(user_data);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Message> CreateMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    MessageType message_type = MessageType_NONE,
    flatbuffers::Offset<void> message = 0,
    const std::vector<uint8_t> *user_data = nullptr) {
  auto user_data__ = user_data ? _fbb.CreateVector<uint8_t>(*user_data) : 0;
  return CreateMessage(
      _fbb,
      message_type,
      message,
      user_data__);
}

inline bool VerifyMessageType(flatbuffers::Verifier &verifier, const void *obj, MessageType type) {
  switch (type) {
    case MessageType_NONE: {
      return true;
    }
    case MessageType_file_target_request: {
      auto ptr = reinterpret_cast<const FileTargetRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType_target_reply: {
      auto ptr = reinterpret_cast<const TargetReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType_exception_location_request: {
      auto ptr = reinterpret_cast<const ExceptionLocationRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType_exception_location_reply: {
      auto ptr = reinterpret_cast<const ExceptionLocationReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType_file_line_breakpoint_request: {
      auto ptr = reinterpret_cast<const FileLineBreakpoint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType_locals_request: {
      auto ptr = reinterpret_cast<const LocalsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType_locals_reply: {
      auto ptr = reinterpret_cast<const LocalsReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType_frame_select_request: {
      auto ptr = reinterpret_cast<const FrameSelectRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType_basic_request: {
      auto ptr = reinterpret_cast<const BasicRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType_callstack_reply: {
      auto ptr = reinterpret_cast<const Callstack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType_source_files_reply: {
      auto ptr = reinterpret_cast<const SourceFilesReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageType(
        verifier,  values->Get(i), types->GetEnum<MessageType>(i))) {
      return false;
    }
  }
  return true;
}

inline const Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<Message>(buf);
}

inline const Message *GetSizePrefixedMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Message>(buf);
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Message>(nullptr);
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Message> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_PDMESSAGES_H_
