// Messages internal and external messages based on Flatbuffers

enum BasicRequestEnum : short {
    SourceFiles,
    Callstack,
}

enum MemoryReplyStatus : byte {
    Ok,
    Partial,
    InvalidRange,
}

enum ExpandVarsTypeEnum : short {
    AllVariables,
    Single,
}

table BasicRequest {
    id: BasicRequestEnum;
}

table SourceFilesReply {
    entries: [string];
}

// Which file target to start debugging (usually an executable)
table FileTargetRequest {
  stop_at_main: bool;
  path: string;
}

// Reply back, true for ok to set target, otherwise false (with optional error string)
table TargetReply {
  status: bool;
  error_message: string;
}

// Get the current location of where the process is halted.
table ExceptionLocationRequest { }

table LocalsRequest {
    tree: [ushort];
    type: ExpandVarsTypeEnum;
}

table MemoryRequest {
    start_address: uint64;
    size: uint64;
}

table MemoryReply {
    start_address: uint64;
    data: [ubyte];
    status: MemoryReplyStatus;
}

// To set a breakpoint on a file and line
table FileLineBreakpoint {
    filename: string;
    line: int;
    add_remove: bool;
}

// Data for variable data frame when debugging with debug info
table Variable {
    name: string;
    value: string;
    type: string;
    address: ulong;
    may_have_children: bool;
}

table CallstackEntry {
    address: ulong;
    desc: string;
    lang: string;
    file: string;
    line: int;
}

table CallstackReply {
    entries: [CallstackEntry];
}

table LocalsReply {
    variables: [Variable];
}

// Reply on the exception location. If filename/line is supported (has debugging info, and correct backend)
// it's expected that the reply will be with those. If only address is supported address should be set.
table ExceptionLocationReply {
    filename: string;
    line: int;
    address: ulong;
}

table FrameSelectRequest {
    frame_index: int;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CPU Registers

enum CPURegisterType : short {
    All,
    Integer,
    FPU,
    Vector,
    Unspecified,
}

table CPURegistersRequest {
    registers_type: CPURegisterType;
}

table CPURegister {
    name: string;
    read_only: bool;
    variable_size: bool;
    type: CPURegisterType;
    data: [ubyte];
}

table CPURegistersReply {
    entries: [CPURegister];
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

union PDMessageType {
    file_target_request: FileTargetRequest,
    target_reply: TargetReply,

    exception_location_request: ExceptionLocationRequest,
    exception_location_reply: ExceptionLocationReply,

    file_line_breakpoint_request: FileLineBreakpoint,

    locals_request: LocalsRequest,
    locals_reply: LocalsReply,

    memory_request: MemoryRequest,
    memory_reply: MemoryReply,

    cpu_registers_request: CPURegistersRequest,
    cpu_registers_reply: CPURegistersReply,

    frame_select_request: FrameSelectRequest,
    basic_request: BasicRequest,
    callstack_reply: CallstackReply,

    source_files_reply: SourceFilesReply,
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Main message that is being passed between backend and frontend. User data can be used
// from both sides to pass extra information around which doesn't fit any of the messages

table PDMessage {
    message: PDMessageType;
    user_data: [ubyte];
}

root_type PDMessage;
