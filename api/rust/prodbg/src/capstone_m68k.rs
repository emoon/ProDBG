// automatically generated by rust-bindgen

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum m68k_reg {
    M68K_REG_INVALID = 0,
    M68K_REG_D0 = 1,
    M68K_REG_D1 = 2,
    M68K_REG_D2 = 3,
    M68K_REG_D3 = 4,
    M68K_REG_D4 = 5,
    M68K_REG_D5 = 6,
    M68K_REG_D6 = 7,
    M68K_REG_D7 = 8,
    M68K_REG_A0 = 9,
    M68K_REG_A1 = 10,
    M68K_REG_A2 = 11,
    M68K_REG_A3 = 12,
    M68K_REG_A4 = 13,
    M68K_REG_A5 = 14,
    M68K_REG_A6 = 15,
    M68K_REG_A7 = 16,
    M68K_REG_FP0 = 17,
    M68K_REG_FP1 = 18,
    M68K_REG_FP2 = 19,
    M68K_REG_FP3 = 20,
    M68K_REG_FP4 = 21,
    M68K_REG_FP5 = 22,
    M68K_REG_FP6 = 23,
    M68K_REG_FP7 = 24,
    M68K_REG_PC = 25,
    M68K_REG_SR = 26,
    M68K_REG_CCR = 27,
    M68K_REG_SFC = 28,
    M68K_REG_DFC = 29,
    M68K_REG_USP = 30,
    M68K_REG_VBR = 31,
    M68K_REG_CACR = 32,
    M68K_REG_CAAR = 33,
    M68K_REG_MSP = 34,
    M68K_REG_ISP = 35,
    M68K_REG_TC = 36,
    M68K_REG_ITT0 = 37,
    M68K_REG_ITT1 = 38,
    M68K_REG_DTT0 = 39,
    M68K_REG_DTT1 = 40,
    M68K_REG_MMUSR = 41,
    M68K_REG_URP = 42,
    M68K_REG_SRP = 43,
    M68K_REG_FPCR = 44,
    M68K_REG_FPSR = 45,
    M68K_REG_FPIAR = 46,
    M68K_REG_ENDING = 47,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum m68k_address_mode {
    M68K_AM_NONE = 0,
    M68K_AM_REG_DIRECT_DATA = 1,
    M68K_AM_REG_DIRECT_ADDR = 2,
    M68K_AM_REGI_ADDR = 3,
    M68K_AM_REGI_ADDR_POST_INC = 4,
    M68K_AM_REGI_ADDR_PRE_DEC = 5,
    M68K_AM_REGI_ADDR_DISP = 6,
    M68K_AM_AREGI_INDEX_8_BIT_DISP = 7,
    M68K_AM_AREGI_INDEX_BASE_DISP = 8,
    M68K_AM_MEMI_POST_INDEX = 9,
    M68K_AM_MEMI_PRE_INDEX = 10,
    M68K_AM_PCI_DISP = 11,
    M68K_AM_PCI_INDEX_8_BIT_DISP = 12,
    M68K_AM_PCI_INDEX_BASE_DISP = 13,
    M68K_AM_PC_MEMI_POST_INDEX = 14,
    M68K_AM_PC_MEMI_PRE_INDEX = 15,
    M68K_AM_ABSOLUTE_DATA_SHORT = 16,
    M68K_AM_ABSOLUTE_DATA_LONG = 17,
    M68K_AM_IMMIDIATE = 18,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum m68k_op_type {
    M68K_OP_INVALID = 0,
    M68K_OP_REG = 1,
    M68K_OP_IMM = 2,
    M68K_OP_MEM = 3,
    M68K_OP_FP_SINGLE = 4,
    M68K_OP_FP_DOUBLE = 5,
    M68K_OP_REG_BITS = 6,
    M68K_OP_REG_PAIR = 7,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct m68k_op_mem {
    pub base_reg: m68k_reg,
    pub index_reg: m68k_reg,
    pub in_base_reg: m68k_reg,
    pub in_disp: u32,
    pub out_disp: u32,
    pub disp: u16,
    pub scale: u8,
    pub bitfield: u8,
    pub width: u8,
    pub offset: u8,
    pub index_size: u8,
    _bindgen_padding_0_: [u8; 1usize],
}
impl ::std::default::Default for m68k_op_mem {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct cs_m68k_op {
    pub _bindgen_data_1_: [u8; 32usize],
    pub type_: m68k_op_type,
    pub address_mode: m68k_address_mode,
}
impl cs_m68k_op {
    pub unsafe fn imm(&mut self) -> *mut u64 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn dimm(&mut self) -> *mut ::std::os::raw::c_double {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn simm(&mut self) -> *mut ::std::os::raw::c_float {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn reg(&mut self) -> *mut m68k_reg {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn reg_pair(&mut self) -> *mut Struct_Unnamed1 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn mem(&mut self) -> *mut m68k_op_mem {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn register_bits(&mut self) -> *mut u32 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for cs_m68k_op {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct Struct_Unnamed1 {
    pub reg_0: m68k_reg,
    pub reg_1: m68k_reg,
}
impl ::std::default::Default for Struct_Unnamed1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum m68k_cpu_size {
    M68K_CPU_SIZE_NONE = 0,
    M68K_CPU_SIZE_BYTE = 1,
    M68K_CPU_SIZE_WORD = 2,
    M68K_CPU_SIZE_LONG = 4,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum m68k_fpu_size {
    M68K_FPU_SIZE_NONE = 0,
    M68K_FPU_SIZE_SINGLE = 4,
    M68K_FPU_SIZE_DOUBLE = 8,
    M68K_FPU_SIZE_EXTENDED = 12,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum m68k_size_type {
    M68K_SIZE_TYPE_INVALID = 0,
    M68K_SIZE_TYPE_CPU = 1,
    M68K_SIZE_TYPE_FPU = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct m68k_op_size {
    pub type_: m68k_size_type,
    pub _bindgen_data_1_: [u32; 1usize],
}
impl m68k_op_size {
    pub unsafe fn cpu_size(&mut self) -> *mut m68k_cpu_size {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn fpu_size(&mut self) -> *mut m68k_fpu_size {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::default::Default for m68k_op_size {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct cs_m68k {
    pub operands: [cs_m68k_op; 4usize],
    pub op_size: m68k_op_size,
    pub op_count: u8,
}
impl ::std::default::Default for cs_m68k {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct cs_detail {
    pub regs_read: [u16; 12],
    pub regs_read_count: u8,
    pub regs_write: [u16; 20],
    pub regs_write_count: u8,
    pub groups: [u8; 8],
    pub groups_count: u8,
    pad: [u8; 1usize],
    // TODO: Add support for other archs here
    pub m68k_data: cs_m68k,
}
